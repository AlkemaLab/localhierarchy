---
title: "Hierarchical models and seq model fits"
author: "Leontine"
format: html
editor: visual
---

See 1parameter version first, this is a shortened one

```{r}
#| include: false
library(here) 
library(tidyverse) 
library(ggplot2) 
library(haven) 
library(stringr)
library(cmdstanr) 
library(bayesplot) # diagnostic plots 
devtools::load_all(here::here())
```

Read in data and preprocess as usual

```{r}
#| include: false
data_folder <- "data_raw" 
dat <- read_csv(here::here(data_folder, "coverage_data.csv"))
```

Let's use columns `cluster` and `subcluster` and `iso`:

```{r}
dat %>% select(iso, cluster, subcluster)
```

Summary of clusters and subclusters, after selecting one row per country

```{r}
dat %>%
  group_by(iso) %>%
  filter(year == max(year)) %>%
  select(country, iso, subcluster, cluster) %>%
  group_by(cluster) %>%
  summarize(nsubclusters = length(unique(subcluster)), ncountries = n())
```

# Model fitting

Easiest 2 parameter set up is to estimate the same mu twice.

(later also use 2 nonses)

global model fit

```{r}
 hierarchical_level     = c("intercept",  "subcluster", "iso")
fit1a <- fit_model_simplified(runstep = "step1a",
                                stan_file_path = file.path(here::here("inst/stan/", "hierfunctions_seq_2param.stan")),
                              mu2param = TRUE, 
        hierarchical_level     =  hierarchical_level,
                  survey_df = dat,
                  chains = 4)

```

create summary object

```{r}
fit1a$post_summ <- get_posterior_summaries_simplified(fit1a) %>%
  dplyr::rename(median = mean)
fit1a$post_summ
fit1a$post_summ %>% filter(variable %in% c("mu_raw[1,1]", "mu_raw[1,2]", "mu_raw[2,1]", "mu_raw[2,2]"))


```

do local fit... here we fix things but do get results for all countries

```{r}
#fit1a$samples <- NULL
fit_local <- fit_model_simplified(runstep = "local_national",
                                    stan_file_path = file.path(here::here("inst/stan/", "hierfunctions_seq_2param.stan")),
                              mu2param = TRUE, 
                  global_fit = fit1a,
                  survey_df = dat,
                  chains = 4)

```

check out extract_parameter_subhier function

```{r}
subhierarchy <- fit$hierarchical_level[1]
hierarchical_data = hierarchical_data(fit$geo_unit, fit$hierarchical_level)
parname = "mu"
fit_samples = fit$samples

```

```{r}
 start <- hierarchical_data$model_matrix$index %>%
    dplyr::filter(column == subhierarchy) %>%
    dplyr::pull(i) %>%
    min()

  end <- hierarchical_data$model_matrix$index %>%
    dplyr::filter(column == subhierarchy) %>%
    dplyr::pull(i) %>%
    max()

  # from bayestransition
  # a_star <- fit$samples$draws(c("a_star")) %>%
  #   tidybayes::spread_draws(a_star[j, i])
  #
  # a_star <- a_star %>%
  #   dplyr::group_by(.data$i, .data$.chain, .data$.iteration, .data$.draw) %>%
  #   dplyr::summarize(a_star =  list(.data[["a_star"]]))
  #

  pars <- c(glue::glue("{parname}_star"))
pars
  star <- fit_samples$draws(pars) %>%
    # for one param
    #tidybayes::spread_draws((!!sym(pars[1]))[i]) %>%
    #dplyr::group_by(.chain, .iteration, .draw) %>%
    tidybayes::spread_draws((!!sym(pars[1]))[i,k]) %>%
     dplyr::group_by(.data$k, .data$.chain, .data$.iteration, .data$.draw) %>%
    tidyr::nest() %>%
    dplyr::mutate(star = map(data, `[[`, glue::glue("{parname}_star"))) %>%
    dplyr::select(-data)
star

```

```{r}
  uniq <- unique(hierarchical_data$model_matrix$mat[, 1:end, drop = FALSE])

  titles <- c()
  for(i in 1:nrow(uniq)) {
    index <- rep(0, hierarchical_data$n_terms)
    index[1:end] <- uniq[i, 1:end]
    title <- hierarchical_data$model_matrix$index %>%
      dplyr::filter(i == last(which(index == 1))) %>%
      dplyr::pull(level)
    titles <- c(titles, title)

    star[[title]] = map_dbl(star[["star"]], function(star) {
      index %*% star
    })
  }

  star <- star %>%
    tidyr::pivot_longer(cols = all_of(titles)) %>%
    dplyr::ungroup() %>%
    dplyr::select(-star)
  star
```

```{r}
quantile_df <- function(x, probs = c(0.025, 0.5, 0.975)) {
  tibble(
    val = quantile(x, probs, na.rm = TRUE),
    quant = probs
  )
}

```

```{r}
star %>% select(name, value, k)  %>% reframe(quantile_df(value), .by = c(name, k))
```

```{r}
fit <- fit1a
mu <- list()
for(subhierarchy in fit$hierarchical_level) {
  mu[[subhierarchy]] <-
    extract_parameter_subhierarchical_simplified_kparam(
      hierarchical_data = hierarchical_data(fit$geo_unit, fit$hierarchical_level),
      subhierarchy = subhierarchy,
      parname = "mu",
      fit_samples = fit$samples)
}

```

```{r}
# mu[[]] has posterior samples for the subhierarchy level
# to get the summaries
res_global <- map(mu, function(tibble_samples) 
#  # for one param
#  tibble_samples %>% select(name, value)  %>% reframe(quantile_df(value), .by = name))
 # for k param
  tibble_samples %>% select(name, value, k)  %>% reframe(quantile_df(value), .by = c(name, k)))
res_global
```

```{r}
fit <- fit_local
mu <- list()
for(subhierarchy in fit$hierarchical_level) {
  mu[[subhierarchy]] <-
#    extract_parameter_subhierarchical_simplified (
  extract_parameter_subhierarchical_simplified_kparam(
    hierarchical_data = hierarchical_data(fit$geo_unit, fit$hierarchical_level),
      subhierarchy = subhierarchy,
      parname = "mu",
      fit_samples = fit$samples)
}
res_local <- map(mu, function(tibble_samples) 
#  tibble_samples %>% select(name, value)  %>% reframe(quantile_df(value), .by = name))
    tibble_samples %>% select(name, value, k)  %>% reframe(quantile_df(value), .by = c(name, k)))
res_local
```

checks that results from local model approximate those from global model

at subcluster level

```{r}
bind_rows(res_local$subcluster %>% mutate(model = "local"),
          res_global$subcluster %>% mutate(model = "global")) %>%
  group_by(name, model, k) %>% 
  reframe(y = val[quant == 0.5], ymin = val[quant == 0.025], ymax = val[quant == 0.975]) %>%
  ggplot(aes(y = y, x = name, color = model)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax)) +
  geom_point()     

```

at country level

```{r}
bind_rows(res_local$iso %>% mutate(model = "local"),
          res_global$iso %>% mutate(model = "global")) %>%
  group_by(name, model, k) %>% 
  reframe(y = val[quant == 0.5], ymin = val[quant == 0.025], ymax = val[quant == 0.975]) %>%
  ggplot(aes(y = y, x = name, color = model)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax)) +
  geom_point()   
```
